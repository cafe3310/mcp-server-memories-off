# 需求: Shell-Native 架构重构

- **状态**: 待办
- **优先级**: 极高

## 1. 目标

对项目的核心技术形态进行重构，将其从一个自包含业务逻辑的 Node.js 应用，转变为一个基于原生 Shell 命令的、跨平台的智能编排器。此举旨在简化核心逻辑、提升执行效率，并充分利用久经考验的系统工具。

## 2. 核心理念：Shell-Native

- **保持协议，改变实现**: 对外，项目继续提供标准的 MCP 服务。对内，所有文件操作的实现将从内部 TypeScript 逻辑，切换为调用 `ShellJS` 库（一个提供跨平台 Shell 命令的 npm 包）。
- **Node.js 作为“胶水”**: TypeScript/Node.js 的职责是接收 MCP 请求，将其翻译成 `ShellJS` 的 API 调用，执行并解析其结果，最后将结果格式化为 MCP 响应。

## 3. 技术选型

- **核心库**: `ShellJS` (`shx`)。该库在 Node.js 环境中重新实现了所有关键的 Unix 命令（如 `ls`, `cat`, `grep`, `sed`），并保证了在 Windows, macOS, Linux 上行为一致，完美解决了跨平台兼容性的挑战。

## 4. 配置与启动方式重构

项目将从单一知识库、基于环境变量的配置，升级为支持多知识库、基于命令行参数的配置。

- **启动命令示例**:
  ```bash
  npx mcp-server-memories-off --name 'my-knowledge-center' --libraries 'work:/path/to/work-docs,personal:/path/to/personal-notes'
  ```
- **`--name`**: 定义此 MCP 服务的全局名称。
- **`--libraries`**: 取代 `MEM_PATH` 环境变量。允许用户一次性挂载一个或多个知识库。每个库由一个唯一的 `名称` 和一个文件系统 `路径` 组成，格式为 `name:path`，多个库之间用逗号分隔。

## 5. 对 MCP 工具集的影响

为了在多知识库模式下进行操作，所有需要与知识库交互的 MCP 工具都必须**增加一个必需的参数**: `library_name: string`。

- **调用示例**: `create_entity(library_name='work', name='new-entity', ...)`
- **影响范围**: 所有涉及实体、关系、搜索等操作的工具都需要进行此项修改。

## 6. 内部核心工具集设计

为了实现“Shell-Native”架构，我们需要定义一套原子化的、基于 ShellJS 的内部工具。这些工具不直接暴露给最终用户，而是作为上层 MCP 工具（如 `upsert_entity`）的实现基础。

### 6.1. 基础文件操作

-   `_create_file(library_name, file_path, content)`: 创建新文件并写入内容。
-   `_delete_files(library_name, file_paths)`: 删除一个或多个文件。

### 6.2. 内容读取 (采用 TOC 机制)

读取操作分为“读取目录 (TOC)”和“读取内容”两步，以实现高效、精确的数据获取。

-   `_read_file_toc(library_name, filename)`: 读取单个 Markdown 文件的目录。返回的目录列表将包含一个特殊的首项 `frontmatter`，指向文件的 YAML front matter，其后是文件中所有 Markdown 标题（如 `## title`）。
-   `_read_many_files_toc(library_name, include_filenames, filename_glob)`: 读取多个文件的目录。

-   `_read_file_content(library_name, filename, toc_glob)`: 读取单个文件中，匹配 `toc_glob` 的特定章节下的内容。
    -   如果 `toc_glob` 是 `frontmatter`，则仅返回 YAML front matter 的内容。
    -   如果 `toc_glob` 是一个标题，则返回该标题到下一个同级或更高级标题之间的所有内容。
-   `_read_many_files_content(library_name, include_filenames, filename_glob, toc_glob)`: 在多个文件中执行上述按 `toc_glob` 读取内容的逻辑。

### 6.3. 内容修改 (基于“上下文匹配”原则)

为了保证操作的健壮性，所有内容修改工具都采用“上下文匹配”原则，避免使用易变的行号。

-   `_replace_content(library_name, file_path, old_content, new_content)`
    -   **`old_content`**: 需要被替换的、包含上下文的精确文本块。
    -   **`new_content`**: 用于替换 `old_content` 的新文本块。

-   `_insert_content(library_name, file_path, after_context, insert_content)`
    -   **`after_context`**: 一个精确的上下文标记，新内容将被插入到此标记之后。
    -   **`insert_content`**: 要插入的新内容。

-   `_delete_content(library_name, file_path, old_content)`
    -   **`old_content`**: 需要被删除的、包含上下文的精确文本块。
    -   **实现**: 可通过调用 `_replace_content` 并将 `new_content` 设为空字符串来实现。

## 7. 对外工具集修订 (以 `manual` 工具为例)

作为新架构实施的第一步，我们将废弃旧的 `manual` 相关工具，并基于新的内部工具集，创建一套全新的、围绕 `meta.md` 进行操作的对外工具。

### 7.1. 设计原则

-   **`manual` 即 `meta.md`**: 所有 `manual` 工具的操作对象都是指定知识库 (`library_name`) 下的 `meta.md` 文件。
-   **用户友好**: 工具参数的设计应符合人类直觉，例如使用 `toc` 参数进行章节定位。
-   **健壮实现**: 工具的内部实现必须调用 `_replace_content` 等基于“上下文匹配”的原子工具，以保证操作的可靠性。

### 7.2. 新 `manual` 工具集定义

-   **`read_manual(library_name)`**
    -   **功能**: 读取指定知识库 `meta.md` 文件的全部内容。
    -   **内部实现**: 调用 `_read_files(library_name, ['meta.md'])`。

-   **`update_manual_section(library_name, toc, old_content, new_content)`**
    -   **功能**: 更新 `meta.md` 中指定章节 (`toc`) 内部的一段内容。
    -   **`toc` 参数处理**: `toc` 参数将被标准化（移除 `##`、忽略大小写）以匹配章节标题。例如，`'章节名'` 和 `'## 章节名'` 效果相同。
    -   **内部实现**: 编排调用 `_read_file_content` 和 `_replace_content`，先读取章节全文，在内存中替换 `old_content` 后，再将整个章节写回。

-   **`add_manual_section(library_name, toc, new_content)`**
    -   **功能**: 在 `meta.md` 中指定章节 (`toc`) 的末尾追加内容。
    -   **内部实现**: 逻辑与 `update` 类似，先读出章节，追加内容后，再将整个章节写回。

-   **`delete_manual_section(library_name, toc, deleting_content)`**
    -   **功能**: 删除 `meta.md` 中指定章节 (`toc`) 内部的一段内容。
    -   **特殊规则**: 如果一个章节的所有内容（除标题外）都被删除，该章节的标题也应一并从 `meta.md` 文件中移除。

## 8. 对外工具集修订 (`relation` 工具)

根据新架构，关系被视为实体 Front Matter 中的“标签”，而非需要全局管理的分类。因此，`relation` 工具集将进行简化和重塑。

### 8.1. 设计原则

-   **废弃类型管理**: `list_relation_types` 和 `merge_relation_types` 工具将被废弃。
-   **原子化操作**: 关系的创建和删除，是针对单个实体文件 Front Matter 的原子化修改操作。
-   **搜索驱动**: 关系的发现，通过 `grep` 等文本搜索工具实现。

### 8.2. 新 `relation` 工具集定义

-   **`create_relations(library_name, relations: [{from: string, to: string, type: string}])`**
    -   **功能**: 在 `from` 实体的 Front Matter 中，添加一条或多条关系记录。
    -   **内部实现**: 对于每条关系，工具将编排调用 `_read_file_content` 来读取 `from` 实体的 `frontmatter`，在内存中向 `relations` 数组追加新条目，然后调用 `_replace_content` 将整个旧的 front matter 替换为新的。

-   **`delete_relations(library_name, relations: [{from: string, to: string, type: string}])`**
    -   **功能**: 从 `from` 实体的 Front Matter 中，删除一条或多条关系记录。
    -   **内部实现**: 逻辑与 `create_relations` 类似，只是在内存中执行的是删除数组条目的操作。

-   **`find_relations(library_name, to_entity: string, relation_type: string)`**
    -   **功能**: 在指定知识库中，根据“关系目标” (`to_entity`) 或“关系类型” (`relation_type`) 搜索关系。所有参数均为可选。
    -   **内部实现**: 该工具是 `grep` 命令的直接应用。它将根据参数动态构建 `grep` 命令（通过 `ShellJS` 执行），在知识库所有 `.md` 文件中进行文本搜索，并返回匹配到的文件名（即 `from_entity`）。

## 9. 对外工具集修订 (`entity` 基础工具)

这是对核心实体 CRUD (创建、读取、更新、删除) 和发现操作的重新设计，旨在为 AI 提供一套原子化、批量化、易于使用的工具。

### 9.1. 实体发现与检查

-   **`list_entities(library_name, entity_glob: string)`**
    -   **功能**: (发现) 基于 `glob` 模式列出实体。此工具取代了原有的 `has_entities`，因为通过 `list_entities(..., '实体名')` 并检查结果是否为空，即可实现存在性检查。
    -   **参数**: `entity_glob` 用于匹配实体名称，例如 `project-*`。
    -   **内部实现**: 将 `entity_glob` 转换为文件 glob 模式（如 `project-*.md`），调用 `ShellJS` 的 `ls` 命令，并处理返回的文件列表以提取实体名称。

### 9.2. 实体创建与删除

-   **`add_entities(library_name, entities: object[])`**
    -   **功能**: (创建) 创建一个或多个新实体。
    -   **`entities` 参数**: 实体对象数组，每个对象包含 `name` (必需), `entity_type` (必需), `aliases` (可选), `relations` (可选), `content` (可选)。
    -   **实现逻辑**: 
        1.  生成文件名并构建含元数据和智能推荐内容的完整文件。
        2.  调用内部工具 `_create_file` 来创建文件。

-   **`delete_entities(library_name, entity_names: string[])`**
    -   **功能**: (删除) 删除一个或多个实体。
    -   **实现逻辑**: 调用内部工具 `_delete_files`。
    -   **关于“断裂链接”**: 此操作的“副作用”由 `garbage_collect_relations` 工具管理。

### 9.3. 实体读取 (三层精度)

-   **`read_entities(library_name, entity_names: string[])`**
    -   **功能**: (通读) 读取一个或多个实体的**全部内容**。

-   **`get_entities_toc(library_name, entity_names: string[])`**
    -   **功能**: (阅览) 快速获取一个或多个实体的**目录结构 (TOC)**。

-   **`read_entities_sections(library_name, entity_names: string[], section_globs: string[])`**
    -   **功能**: (精读) 精确读取一个或多个实体中，与 `section_globs` 匹配的**特定章节的内容**。

### 9.4. 实体操作与维护

-   **`rename_entity(library_name, old_name, new_name)`**
    -   **功能**: (重命名) 对一个实体进行“深度重命名”。
    -   **实现逻辑**:
        1.  **检查冲突**: 确保 `new_name` 没有被占用。
        2.  **重命名文件**: 调用 `ShellJS` 的 `mv` 命令重命名实体文件。
        3.  **修复链接**: 在知识库所有文件中执行全局搜索与替换，将所有 `relation to: <old_name>` 更新为 `relation to: <new_name>`。
        4.  **更新元数据**: 更新文件内的 `date modified` 字段。

-   **`merge_entities(library_name, source_names: string[], target_name: string)`**
    -   **功能**: (合并) 将多个源实体合并入一个目标实体，然后删除源实体。
    -   **实现逻辑**:
        1.  **预检查**: 确保所有源实体和目标实体都存在。
        2.  **合并元数据**: 读取所有实体，在内存中将源实体的 `aliases` 和 `relations` 合并到目标实体的 Front Matter 中（去重）。
        3.  **合并正文**: 将每个源实体的正文内容，通过分隔符和说明文字，追加到目标实体的正文末尾。
        4.  **更新目标实体**: 使用 `_replace_content` 将合并后的新内容写回目标实体文件。
        5.  **全局链接修复**: 对每个 `source_name`，执行一次全局搜索与替换，将所有指向它的关系都重定向到 `target_name`。
        6.  **删除源实体**: 调用 `_delete_files` 删除所有源实体文件。
        7.  **记录日志**: 在 `journey.yaml` 中记录整个合并过程。

### 9.5. 实体内容编辑

-   **`add_entity_content(library_name, entity_name, in_section, new_content)`**
    -   **功能**: (追加内容) 在指定实体、指定章节 (`in_section`) 的末尾追加新内容。
    -   **实现**: 先读取 `in_section` 的完整内容，追加 `new_content` 后，再用 `_replace_content` 将整个章节写回。

-   **`delete_entity_content(library_name, entity_name, content_to_delete)`**
    -   **功能**: (删除内容) 从指定实体中，精确删除一段内容。
    -   **实现**: 直接调用 `_delete_content`，使用上下文匹配原则。

-   **`replace_entity_section(library_name, entity_name, old_heading, new_heading, new_body_content)`**
    -   **功能**: (重写章节) 重写一个完整的章节，可同时修改章节标题和其全部正文。
    -   **实现**: 工具会根据 `old_heading` 定位并读取旧章节的完整文本，然后用 `new_heading` 和 `new_body_content` 构成新的完整章节文本，最后调用 `_replace_content` 完成替换。
